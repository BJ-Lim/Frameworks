## 기본 용어
- 미들웨어 : 분산 컴퓨팅 환경에서 서로 다른 기종의 하드웨어나 프로토콜, 통신환경 등을 연결하여, 응용프로그램과 그 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있게 하는 소프트웨어
- 펌웨어 : 읽기 전용 메모리에 영구 저장되어 있는 실행 가능한 명령어
- 프로세서 : CPU(Central Processing Unit)
- 주 기억장치 : RAM(Random access memory)
- 입출력(I/O) 모듈 : 보조 기억장치, 통신 장치, 터미널
- 버스(bus) : 데이터가 이동하는 통로
- ALU(Arithmetic and Logic Unit) : 산술 연산 및 논리 연산
- DMA(Direct Memory Access) : 직접 메모리 접근. 디바이스 제어기가 CPU의 중재 없이 제어기 버퍼에서 메모리로 직접 전송
- 인쇄 회로 기판 : PCB(Printed Circuit Board)
- 메인보드 : 시스템의 중심 PCB

## 컴파일
- 컴파일링 : 고급 언어로 작성한 코드를 기계어로 변환하는 작업
- 링킹 : 프로그램에서 참조하는 모듈을 실행 가능하도록 한 단위로 통합하는 과정
- 로딩 : 명령어와 데이터를 특정 메모리 주소에 배치하는 과정

## 프로세스
- 프로그램 : 디스크상에 저장된 파일의 내용
- 프로세스 : 작업의 기본 단위. 실행중인 프로그램
- PCB(Process Control Block) : 프로세스 마다 존재하는 작업 수행에 필요한 내용들(문맥 전환시 저장되는 내용)
- 문맥 전환(context switches) : OS에 의해 실행중인 프로세스를 멈추고 준비상태의 다른 프로세스 실행
  - 실행중인 프로세스의 문맥을 해당 프로세스의 PCB에 저장
  - 실행할 준비 상태 프로세스의 이전 실행 문맥을 PCB에서 읽어 로드
  - 문맥 전환 비용은 불필요한 비용임
- 시스템 호출(System call) : 사용자 프로세스가 운영체제의 기능을 불러 사용하는 것
- IPC(InterProcess Comunication) : 프로세스간 통신
  - 시그널(signal) : 프로세스에 이벤트가 발생했음을 알리는 소프트웨어 인터럽트
  - 메세지 : 단방향성
    - 블로킹 / 논블로킹
    - 파이프 : 운영체제에서 보호하는 메모리 영역으로 버퍼 역할을 함

## 프로세스 스케쥴링
- 디스패쳐 : 프로세스의 문맥 교환시 호출됨
- 평균 대기 시간(average waiting time) : 모든 프로세스들의 대기시간을 평균낸 시간
- 평균 반환 시간 : 모든 프로세스들이 종료된 시간을 평균낸 시간
- Burst Time : 프로세스가 실행되는데 필요한 시간
- 선점 스케쥴링 : 프로세스가 수행중일 때 임의의 순간에 수행을 중지하고 다른 프로세스 실행 가능
  - RR(Round Robin) : 각 프로세스에게 일정한 타임 퀀텀을 할당한 후 해당 시간 경과 후에 프로세서 양도
  - SRT(Shortest Remaining Time) : SJF와 동일하나, 현재 실행중인 프로세스보다 더 짧은 수행시간이 남은 프로세스가 준비상태이면 해당 프로세스 실행
- 비선점 스케쥴링 : 수행중인 프로세스가 자발적으로 CPU를 양도할 때까지 다른 프로세스들은 수행 불가
  - FCFS(First Come, First Srerved) : 프로세스가 CPU를 차지하면 완료될 때까지 수행
  - SJF(Shortest Job First) : 수행 시간이 가장 작은 프로세스에게 우선순위를 할당
  - Priority : 각 프로세스마다 고유한 우선순위를 할당
- 에이징(aging) 기법 : 낮은 우선순위를 가진 프로세스의 기아방지를 위해서 일정 시간마다 우선순위를 높이는 방법

## 쓰레드
- 쓰레드 : 경량 프로세스
  - 사용자 수준 쓰레드 : 다대일로 프로세서에 매핑
  - 커널 수준 쓰레드 : 일대일로 프로세서에 매핑

## 동기화 문제 및 해결
- 경쟁 상태 : 병행으로 수행되는 여러 프로세스가 공통된 데이터를 조작할 때 결과가 접근 순서에 의해 결정되는 것
- 프로세스 동기화 : 여러프로세스가 병행으로 수행됭 발생하는 문제를 해결하는 것
- 상호 배제(Mutual Exclusion) : 한 프로세스가 공유 공간을 사용할 때, 다른 프로세스들이 사용하지 못하도록 배제
  - 임계 영역 : 공유 데이터를 변경시키는 부분
  - SW 해결법
    - 두개의 프로세스
      - 데커 알고리즘 / 피터슨 알고리즘 : flag & turn을 사용하여 양보하며 임계영역 진입 허용
    - 다중 프로세스
      - 베이커리 알고리즘 : FCFS순서로 티켓을 발급받아 crtical section 진입
      - 세마포어
        - 모든 프로세스는 mutex라는 세마포어를 공유
        - mutex는 1로 초기화
        - wait(mutext)과 signal(mutex)은 원자적
        - wait : critical section 진입 전 mutex가 0 이하이면 무한정 대기, 아니면 mutex를 1 줄이고 진입
        - signal : critical section 탈출 후 mutex 1 증가
  - HW 해결법
    - 인터럽트 억제 : 공유 변수 사용중 인터럽트 억제
      - 스레드가 임계영역에서 I/O 실행시 교착상태 발생
    - TestAndSet / swap : 공유변수 변경을 원자화하는 하드웨어 명령 제공
      - 원자적이다 : 명령어 수행중 인터럽트 발생 없음

## 디스크 
### 스케쥴링
- FCFS : 도착한 순서대로 실행
- SSTF : 처리할 작업중 가장 가까운 위치의 작업 실행
- SCAN : 작업 -> 디스크의 시작 -> 디스크의 끝 순서로 왕복하며 작업 실행
- C-SCAN : 디스크의 시작 -> 디스크의 끝 도달 후 작업 수행 없이 디스크의 시작으로 돌아감
- C-LOOK : C-SCAN과 같지만, 디스크의 시작과 끝이 아닌 요청된 블럭 중 시작과 끝을 구해서 실행
### RAID
- 6개의 레벨로 구성되어 있다.
- 레벨별로 데이터 중복 저장의 정도 / 에러 검출 정도가 결정된다.
- 레벨에 따라 속도가 더 빨라질 수 있으며, 고장날 확률이 올라갈 수 있다.


## 파일 시스템
- 정의 : 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제
- 디바이스 드라이버 : 물리 장치를 제어하는 역할

## 메모리
- 내부 단편화 : 메모리 블럭의 총 합이 프로세스가 요청하는 메모리보다 커서 공간이 남는 경우
- 외부 단편화 : 메모리에 남은 블럭의 합은 프로세스가 요청하는 크기보다 크지만, 블럭이 연속되지 않아 프로세스를 할당할 수 없는 경우
- 고정 분할 할당 : 메모리를 고정된 N개의 블록으로 분할. 블록의 크기는 동일하거나 다양
- 가변 분할 할당 알고리즘 : 블럭의 크기, 개수 및 위치를 가변적으로 물리 메모리를 다양한 크기를 가진 블록으로 분할
  - 최초 적합(First-fit) : 적재되기 충분한 첫번째 블록을 할당
  - 최적 적합(Best-fit) : 단편화가 가장 적은 블록을 할당
  - 최악 적합(Worst-fit) : 단편화가 가장 큰 블록을 할당
- 동적 적재(dynamic loading) : 프로그램을 구성하는 루틴이 실제 호출되기 전까지 메모리에 적재되지 않는 방식
- 정적 링킹(static linking) : 모든 프로그램이 라이브러리의 복사본을 가짐
- 동적 링킹(dynamic linking) : 링킹이 수행시간에 이루어짐(ex] window dll, 유닉스 동적 라이브러리)
- 스와핑(swapping) : 메모리 부족시 2차 저장장치에 내용을 잠시 저장해두는 방식
- 메모리 관리 방법
  - 비트맵(bit maps) : 메모리를 일정한 크기의 블럭의 유닛으로 분할하고, 각 유닛을 표현하는 비트맵을 사용
  - 연결 리스트(Linked list) : 메모리 할당 유닛이 사용중인 것과 사용하지 않는 것이 각각의 연결리스트에 연결되어 있는 방식
  - 버디 시스템(Buddy System) : 메모리 관리자는 메모리 블럭을 2의 승수로 할당하여 자유 메모리 결합을 빠르게 하는 방식

## 가상 메모리
- 목적 : 사용자 프로그램은 논리적인 주소만을 다루고, 실제 물리 주소에 대해서는 신경쓰지 않아도 된다
- 페이징 : 프로세스가 수행되어야 하는 주소 공간이 물리적으로 연속적이어야 한다는 제약을 없애는 방법
- 프레임 : 물리적 기억장치를 고정된 크기로 나눈 것
- MMU(Memory Management Unit) : 가상 주소를 물리 주소로 변환해주는 하드웨어 장치
  - CPU 내부에 위치
  - TLB(Translation look-aside buffer)라는 주소 변환용 전용 캐시를 가짐
- 블록 사상(block mapping)
  - 사상 테이블(map table) : 가상 주소와 이에 대응되는 실 주소를 저장
  - 프로그램을 블럭단위로 구분하여 블럭 단위로 주기억 장치에 적재
  - 가상 주소 v를 (b,d)로 표현
  - b : 프로그램을 블럭 단위로 분할 했을 때 블럭 번호
  - d : 해당 블럭에서의 변위(offset)
- 주소 변환 과정
  - 해당 프로세스의 블록 사상 테이블에 접근
  - 테이블에서 블럭에 대한 엔트리를 찾아 실 주소 a값을 인출
  - 인출된 값 a와 주소의 변위 d를 더하여 실주소 구함
    - r = a + d
  - 실 주소 r로 주기억 장치 접근
  - ex) 32비트 시스템의 경우
    - 메모리 최대 크기 : 4GB = 2^32B
    - 블록 크기 : 4KB = 2^12B
    - 블록의 수 : 4GB / 4KB = 2^20
    - 주소의 표현 : 앞의 20비트 = 블록의 위치(페이지 번호), 뒤의 12비트는 해당 블록에서의 위치(offset, 페이지 변위)
    - 주소는 메모리의 특정 위치의 Byte를 가리킴
  - 2단계 페이징 : 페이지 테이블을 모두 메모리에 적재하면 크기가 너무 크므로, 선택적으로 적재하여 메모리를 절약하는 방법
- 공유 페이지 : 프로세스간에 읽기 전용 코드에 대해서 공유
- 세그먼트 : 사용자 관점의 메모리 관리 기법
  - 데이터 부분 : 읽기/쓰기 속성으로 보호
  - 명령어 부분 : 읽기/실행 속성으로 보호

## 페이지 교체정책
- Demand Paging : 메모리에 프로세스를 전체 올리지 않고, 필요한 시점에 필요한 부분을 올리는 기법
- Page Fault : 페이지가 메모리에 올라와있지 않은 경우 발생
- COW(Copy-on-Write) : 부모 프로세스와 자식 프로세스가 공통된 페이지를 공유하다가, 수정이 발생하면 복사해서 수정하는 방식
- 교체 알고리즘
  - FIFO(First-In-First-Out) : 먼저 들어온 것을 먼저 버리는 방식
    - Belady's Anomaly : 프레임의 사이즈를 키웠음에도 page fault가 증가하는 현상
  - Optimal Algorithm : 가장 최근에 사용되지 않을(미래) 페이지를 우선적으로 교체
    - 미래 예측이 불가능 하기 때문에, 성능 측정의 지표로만 활용되며 구현을 거의 불가능
  - LRU(Reast Recently Used) : 가장 최근에 사용되지 않은(과거) 페이지를 교체
  - LFU(Lease Frequently Used) : 가장 적게 카운트된 페이지를 교체
  - MFU(Most Frequently Used) : 가장 많이 카운트된 페이지를 교체
- Thrashing : 프로세스가 충분한 페이지를 확보하지 못해서 page fault가 매우 높에 일어나는 현상
  - 해당 현상중에는 프로세스가 페이지를 스와핑하기 바쁜 상태를 의미한다
- working set : 프로세스별로 자주 사용하는 페이지
- Trim : 메모리 공간이 부족하여 프로세스의 working set중 최근에 사용되지 않은 것을 지우는 방법으로, 수행이 많이 될수록 page fault가 증가
- Memory-Mapped Files : 디스크 블록(2차 저장장치의 블록)을 메모리 페이지(주 메모리)에 매핑하여 처리하는 방법
