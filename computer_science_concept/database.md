### 추상화 단계
- 물리 단계 : 레코드가 어떻게 저장되었는지를 기술
- 논리 단계 : DB에 저장된 데이터와 데이터간의 관계를 기술
- 뷰 단계 : 응용 프로그램은 데이터 형의 상세 사항은 감춤

### 용어
- 스키마 : DB의 논리 구조
- 데이터 독립성 : 차상위 단계의 스키마 정의에 영향을 주지 않고 어떤 단계의 스키마 정의를 수정할 수 있는 능력

## 관계형 데이터베이스(Relational Database)
- 정의 : 키와 값들을 테이블화 시킨 데이터베이스
- 용어
  - 속성 값(attribute types) : 데이터
    - 원자값의 성질을 만족해야 한다
  - 도메인(domain) : 속성 값으로 허용 되는 값의 집합
    - 널(null)값은 모든 도메인에 포함됨
  - 슈퍼키(super key) : K의 값이 릴레이션의 고유한 튜플을 구분하는데 충분하다면 K는 슈퍼키이다
  - 후보키(candidate Key) : 슈퍼키가 최소한의 조건을 만족시키면 후보키이다
  - 주키(primary key) : 후보키중 하나가 주키로 선택된다
  - 외래키 제약조건 : 릴레이션 내 속성 값이 다른 릴레이션에 존재해야 한다
- 특징
  - 튜플들의 순서에는 의미가 없다

### 설계(Relational Database Design)
- 함수 종속 : 어떤 애트리뷰트의 집합의 값이 다른 애트리뷰트의 집합의 값을 유일하게 결정하도록 요구
- 설계 목표
  - 중복 데이터 회피
  - 애트리뷰트간의 관계가 표현되도록 보장
  - 무결성 제약 조건의 위배에 대한 갱신 검사의 용이성
- 정규화 : 큰 데이터베이스를 작게 쪼개서 중복을 최소화하는 방법
  - 제 1 정규형(First Normal Form) : 모든 속성의 도메인이 원자형의 조건을 만족
    - 즉, 각 튜플의 어트리뷰트 값들은 1개씩만 존재
  - 제 2 정규형(Second Normal Form) : 1NF만족 + 후보키 내의 모든 속성을 사용해야만 다른 속성을 정의 가능
    - (후보키의) 부분적 함수 종속 제거
      - 부분적 함수 종속 : 후보키의 일부 속성이 다른 속성을 결정 가능
  - 제 3 정규형(Third Normal Form) : 2NF만족 + 키가 아닌 모든 속성이 모든 키에 이행적 종속이 되지 않는다
    - 이행적 함수 종속 : X->Y 이고 Y->Z 이면 X->Z
  - BCNF(Boyce and Codd Normal Form) : 모든 결정자가 후보키 집합에 속한 정규형
    - 후보키가 아닌 속성이 다른 속성을 결정해서는 안됨
  - 제 4 정규형(Fourth Normal Form) : 다중값 종속을 해결한 정규형

## Entiry-Relationship 모델
- 약 엔티티 집합(Weak Entiry Sets)
  - 주 키를 갖지 앟는 엔티티 집합
  - 강 엔티티 집합이 있어야만 존재
  - 약 엔티티 집합의 주키는 강 엔티티 집합의 주키와 결합되어 이루어짐
  
## 인덱싱(Indexing)
- 용어
  - 밀집 인덱스 : 인덱스 레코드가 파일 내의 각 검색 키 값에 대해 나타남
- 종류
  - 순서 인덱스(Ordered indices) : 검색 키가 정렬된 순서로 저장
    - 주 인덱스(primary index) : 순차적으로 정렬된 파일에서는 검색키 인덱스가 파일의 순차적인 순서를 지정
    - 2차 인덱스(secondary index) : 검색키 인덱스가 파일의 순차적인 순서와는 다른 순서를 지정
      - 밀집 인덱스여야 함
      - 메모리 엑세스보다 블럭 엑세스 비용이 많이 들어감
    - 희소 인덱스(sparse index) : 몇 개의 검색 키 값에 대한 인덱스 레코드만을 포함
      - 인덱스의 사이 값은 디스크의 사이 범위를 순차적으로 탐색함
      - 블록별로 가장 작은 검색 키 값을 가지도록 희소인덱스를 구성하면 효과적
  - 해쉬 인덱스(Hash indices) : 검색 키가 해쉬 함수를 사용해 버켓들에 균등하게 분산
    - 정적 해슁 : 해쉬 함수가 정적으로 고정된다
      - 크기가 커지면 성능이 감소한다
    - 동적 해슁 : 해쉬 함수가 동적으로 수정된다
      - 크기가 커져도 성능은 감소하지 않는다
      - 레코드 검색을 위해서 부가적인 포인터 추적이 필요하다
